
(* 
Define a function mem_factorial which takes a unit as an argument and returns 1 the first
time it is called, returns 2 the second time it is called, returns 6 the third time it is called, and
so on. In general, the function should return n! on the nth time it is called. 
*)

let mem_factorial _ = failwith "not implemented" ;;


(* Define a non-recursive implementation of List.filter *)
let filter_imper _ = failwith "not implemented" ;; 

(* range n m returns a list that contains all the integers from n to m-1 inclusive. Define three
versions of the range function: (1) a tail-recursive version, (2) a non-tail recursive version,
and (3) a procedural implementation (using loops) *)

let range _ = failwith "not implemented" ;; 

(* Define a function that merges two sorted (in ascending order) mutable lists. This function
should return a value of type unit and the first list should become the merging of the two lists *)
let merge _ = failwith "not implemented" ;; 

(* Define a function that generates the Fibonacci numbers (i.e. fib(i) the ith time the function
is called *)
let fib _ = failwith "not implemented" ;;


(* Rewrite power from Part 2 (see Problem 6) to improve the worst-case time complexity. 
What is the asymptotic runtime of the function right now? *)
let rec power _ = failwith "not implemented" ;;